//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

extension API.Payments {

    /** Checkout.com supports payments from a variety of sources, from card payments to 
SEPA direct debits. The source of payment can be specified using the `source.type` field along with any source specific data.

To verify the success of the payment, check the `approved` field in the response.

### Reference Tokens

The most common way of making card payments is using a token generated by [Checkout Frames](#). 
This is mandatory for non-PCI compliant merchants as it ensures no card details are transferred to your server. 
This integration method also applies to digital wallets such as Apple Pay and Google Pay.

Note: Reference tokens expire after 15 minutes.

```json
{
  "source": {
    "type": "token",
    "token": "tok_ubfj2q76miwundwlk72vxt2i7q",
    "billing_address": { ... },
    "phone": { ... }
  },
  "amount": 5600,
  "currency": "GBP"
}
```

#### Full Card Details

To make a card payment specify the source type card.

Note that full card payments should only be requested by PCI compliant merchants.

```json
{
  "source": {
    "type": "card",
    "number": "4242424242424242",
    "expiry_month": 6,
    "expiry_year": 2018
  },
  "amount": 5600,
  "currency": "GBP"
}
```

### Existing Source

When a card payment is processed you will be returned a source identifier that can later be used to make payments. 
You can also add payment sources for Alternative Payments via the [Sources API](#tag/Sources).

```json
{
  "source": {
    "type": "id",
    "id": "src_wmlfc3zyhqzehihu7giusaaawu",
    "cvv" "843"
  },
  "amount": 5600,
  "currency": "GBP"
}
```

### Customer

You can provide the ID or email of an existing customer to make a payment using their default payment method.

```json
{
  "source": {
    "type": "customer",
    "id": "cus_y3oqhf46pyzuxjbcn2giaqnb44",
  },
  "amount": 5600,
  "currency": "GBP"
}
```

### Alternative Payments

Checkout.com supports a number of alternative payment methods. Reusable payment sources such as SEPA Direct Debits must first be created via the [Sources API](#tag/Sources).

For non-reusable payment methods such as those that use a redirect flow (e.g. iDEAL), provide the name of the payment method as the source.type along with any payment method specific data.

```json
{
  "source": {
    "type": "ideal",
    "issuer_id": "TESTISSUER01"
  },
  "amount": 5600,
  "currency": "GBP"
}
```
 */
    public enum PostPayments {

        public static let service = APIService<Response>(id: "postPayments", tag: "Payments", method: "POST", path: "/payments", hasBody: true)

        public final class Request: APIRequest<Response> {

            public var body: PaymentRequest

            public init(body: PaymentRequest) {
                self.body = body
                super.init(service: PostPayments.service) {
                    let jsonEncoder = JSONEncoder()
                    return try jsonEncoder.encode(body)
                }
            }
        }

        public enum Response: APIResponseValue, CustomStringConvertible, CustomDebugStringConvertible {
            public typealias SuccessType = PaymentResponse

            /** Payment processed successfully */
            case status201(PaymentResponse)

            /** Payment asynchronous or further action required */
            case status202(PaymentAcceptedResponse)

            /** Unauthorized */
            case status401

            /** Invalid data was sent */
            case status422(ValidationError)

            /** Bad gateway */
            case status502

            public var success: PaymentResponse? {
                switch self {
                case .status201(let response): return response
                default: return nil
                }
            }

            public var failure: ValidationError? {
                switch self {
                case .status422(let response): return response
                default: return nil
                }
            }

            /// either success or failure value. Success is anything in the 200..<300 status code range
            public var responseResult: APIResponseResult<PaymentResponse, ValidationError> {
                if let successValue = success {
                    return .success(successValue)
                } else if let failureValue = failure {
                    return .failure(failureValue)
                } else {
                    fatalError("Response does not have success or failure response")
                }
            }

            public var response: Any {
                switch self {
                case .status201(let response): return response
                case .status202(let response): return response
                case .status422(let response): return response
                default: return ()
                }
            }

            public var statusCode: Int {
                switch self {
                case .status201: return 201
                case .status202: return 202
                case .status401: return 401
                case .status422: return 422
                case .status502: return 502
                }
            }

            public var successful: Bool {
                switch self {
                case .status201: return true
                case .status202: return true
                case .status401: return false
                case .status422: return false
                case .status502: return false
                }
            }

            public init(statusCode: Int, data: Data) throws {
                let decoder = JSONDecoder()
                switch statusCode {
                case 201: self = try .status201(decoder.decode(PaymentResponse.self, from: data))
                case 202: self = try .status202(decoder.decode(PaymentAcceptedResponse.self, from: data))
                case 401: self = .status401
                case 422: self = try .status422(decoder.decode(ValidationError.self, from: data))
                case 502: self = .status502
                default: throw APIError.unexpectedStatusCode(statusCode: statusCode, data: data)
                }
            }

            public var description: String {
                return "\(statusCode) \(successful ? "success" : "failure")"
            }

            public var debugDescription: String {
                var string = description
                let responseString = "\(response)"
                if responseString != "()" {
                    string += "\n\(responseString)"
                }
                return string
            }
        }
    }
}
